// Code generated by goagen v1.2.0-dirty, DO NOT EDIT.
//
// API "samclick": users Resource Client
//
// Command:
// $ goagen
// --design=github.com/kasoshojo/api/design
// --out=$(GOPATH)src/github.com/kasoshojo/api
// --version=v1.2.0-dirty

package client

import (
	"bytes"
	"context"
	"fmt"
	"net/http"
	"net/url"
	"time"
)

// AddcodeUsersPayload is the users addcode action payload.
type AddcodeUsersPayload struct {
	Code string `form:"code" json:"code" xml:"code"`
}

// AddcodeUsersPath computes a request path to the addcode action of users.
func AddcodeUsersPath() string {

	return fmt.Sprintf("/users/me/codes")
}

// Add a voting code
func (c *Client) AddcodeUsers(ctx context.Context, path string, payload *AddcodeUsersPayload) (*http.Response, error) {
	req, err := c.NewAddcodeUsersRequest(ctx, path, payload)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewAddcodeUsersRequest create the request corresponding to the addcode action endpoint of the users resource.
func (c *Client) NewAddcodeUsersRequest(ctx context.Context, path string, payload *AddcodeUsersPayload) (*http.Request, error) {
	var body bytes.Buffer
	err := c.Encoder.Encode(payload, &body, "*/*")
	if err != nil {
		return nil, fmt.Errorf("failed to encode body: %s", err)
	}
	scheme := c.Scheme
	if scheme == "" {
		scheme = "http"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	req, err := http.NewRequest("POST", u.String(), &body)
	if err != nil {
		return nil, err
	}
	header := req.Header
	header.Set("Content-Type", "application/json")
	if c.JWTSigner != nil {
		c.JWTSigner.Sign(req)
	}
	return req, nil
}

// ForgotpasswordUsersPayload is the users forgotpassword action payload.
type ForgotpasswordUsersPayload struct {
	Securityanswer   string `form:"securityanswer" json:"securityanswer" xml:"securityanswer"`
	Securityquestion string `form:"securityquestion" json:"securityquestion" xml:"securityquestion"`
	// Username
	Username string `form:"username" json:"username" xml:"username"`
}

// ForgotpasswordUsersPath computes a request path to the forgotpassword action of users.
func ForgotpasswordUsersPath() string {

	return fmt.Sprintf("/users/forgot")
}

// Retrieve a new password
func (c *Client) ForgotpasswordUsers(ctx context.Context, path string, payload *ForgotpasswordUsersPayload) (*http.Response, error) {
	req, err := c.NewForgotpasswordUsersRequest(ctx, path, payload)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewForgotpasswordUsersRequest create the request corresponding to the forgotpassword action endpoint of the users resource.
func (c *Client) NewForgotpasswordUsersRequest(ctx context.Context, path string, payload *ForgotpasswordUsersPayload) (*http.Request, error) {
	var body bytes.Buffer
	err := c.Encoder.Encode(payload, &body, "*/*")
	if err != nil {
		return nil, fmt.Errorf("failed to encode body: %s", err)
	}
	scheme := c.Scheme
	if scheme == "" {
		scheme = "http"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	req, err := http.NewRequest("POST", u.String(), &body)
	if err != nil {
		return nil, err
	}
	header := req.Header
	header.Set("Content-Type", "application/json")
	if c.JWTSigner != nil {
		c.JWTSigner.Sign(req)
	}
	return req, nil
}

// GetquestionUsersPath computes a request path to the getquestion action of users.
func GetquestionUsersPath() string {

	return fmt.Sprintf("/users/question")
}

// Get security question
func (c *Client) GetquestionUsers(ctx context.Context, path string, username *string) (*http.Response, error) {
	req, err := c.NewGetquestionUsersRequest(ctx, path, username)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewGetquestionUsersRequest create the request corresponding to the getquestion action endpoint of the users resource.
func (c *Client) NewGetquestionUsersRequest(ctx context.Context, path string, username *string) (*http.Request, error) {
	scheme := c.Scheme
	if scheme == "" {
		scheme = "http"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	values := u.Query()
	if username != nil {
		values.Set("username", *username)
	}
	u.RawQuery = values.Encode()
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	return req, nil
}

// RegisterUsersPath computes a request path to the register action of users.
func RegisterUsersPath() string {

	return fmt.Sprintf("/users/")
}

// Register a new user
func (c *Client) RegisterUsers(ctx context.Context, path string, payload *Registerrequest) (*http.Response, error) {
	req, err := c.NewRegisterUsersRequest(ctx, path, payload)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewRegisterUsersRequest create the request corresponding to the register action endpoint of the users resource.
func (c *Client) NewRegisterUsersRequest(ctx context.Context, path string, payload *Registerrequest) (*http.Request, error) {
	var body bytes.Buffer
	err := c.Encoder.Encode(payload, &body, "*/*")
	if err != nil {
		return nil, fmt.Errorf("failed to encode body: %s", err)
	}
	scheme := c.Scheme
	if scheme == "" {
		scheme = "http"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	req, err := http.NewRequest("POST", u.String(), &body)
	if err != nil {
		return nil, err
	}
	header := req.Header
	header.Set("Content-Type", "application/json")
	return req, nil
}

// UpdateUsersPayload is the users update action payload.
type UpdateUsersPayload struct {
	// Birthdate
	Birthdate *time.Time `form:"birthdate,omitempty" json:"birthdate,omitempty" xml:"birthdate,omitempty"`
	// Codes
	Codes []string `form:"codes,omitempty" json:"codes,omitempty" xml:"codes,omitempty"`
	// Record created timestamp
	CreatedAt *time.Time `form:"created_at,omitempty" json:"created_at,omitempty" xml:"created_at,omitempty"`
	// Given names
	GivenNames *string `form:"given_names,omitempty" json:"given_names,omitempty" xml:"given_names,omitempty"`
	// Unique ID
	ID int `form:"id" json:"id" xml:"id"`
	// Last names
	LastNames *string `form:"last_names,omitempty" json:"last_names,omitempty" xml:"last_names,omitempty"`
	// Location
	Location *string `form:"location,omitempty" json:"location,omitempty" xml:"location,omitempty"`
	// E-mail address
	Mail *string `form:"mail,omitempty" json:"mail,omitempty" xml:"mail,omitempty"`
	// Points
	Points *int `form:"points,omitempty" json:"points,omitempty" xml:"points,omitempty"`
	// User status
	Status *int `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// Record updated timestamp
	UpdatedAt *time.Time `form:"updated_at,omitempty" json:"updated_at,omitempty" xml:"updated_at,omitempty"`
	// Username
	Username string `form:"username" json:"username" xml:"username"`
}

// UpdateUsersPath computes a request path to the update action of users.
func UpdateUsersPath() string {

	return fmt.Sprintf("/users/me")
}

// Update user by authorization token
func (c *Client) UpdateUsers(ctx context.Context, path string, payload *UpdateUsersPayload) (*http.Response, error) {
	req, err := c.NewUpdateUsersRequest(ctx, path, payload)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewUpdateUsersRequest create the request corresponding to the update action endpoint of the users resource.
func (c *Client) NewUpdateUsersRequest(ctx context.Context, path string, payload *UpdateUsersPayload) (*http.Request, error) {
	var body bytes.Buffer
	err := c.Encoder.Encode(payload, &body, "*/*")
	if err != nil {
		return nil, fmt.Errorf("failed to encode body: %s", err)
	}
	scheme := c.Scheme
	if scheme == "" {
		scheme = "http"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	req, err := http.NewRequest("PUT", u.String(), &body)
	if err != nil {
		return nil, err
	}
	header := req.Header
	header.Set("Content-Type", "application/json")
	if c.JWTSigner != nil {
		c.JWTSigner.Sign(req)
	}
	return req, nil
}

// UpdatepasswordUsersPayload is the users updatepassword action payload.
type UpdatepasswordUsersPayload struct {
	OldPassword *string `form:"oldPassword,omitempty" json:"oldPassword,omitempty" xml:"oldPassword,omitempty"`
	Password    string  `form:"password" json:"password" xml:"password"`
}

// UpdatepasswordUsersPath computes a request path to the updatepassword action of users.
func UpdatepasswordUsersPath() string {

	return fmt.Sprintf("/users/me/password")
}

// Set a new password
func (c *Client) UpdatepasswordUsers(ctx context.Context, path string, payload *UpdatepasswordUsersPayload) (*http.Response, error) {
	req, err := c.NewUpdatepasswordUsersRequest(ctx, path, payload)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewUpdatepasswordUsersRequest create the request corresponding to the updatepassword action endpoint of the users resource.
func (c *Client) NewUpdatepasswordUsersRequest(ctx context.Context, path string, payload *UpdatepasswordUsersPayload) (*http.Request, error) {
	var body bytes.Buffer
	err := c.Encoder.Encode(payload, &body, "*/*")
	if err != nil {
		return nil, fmt.Errorf("failed to encode body: %s", err)
	}
	scheme := c.Scheme
	if scheme == "" {
		scheme = "http"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	req, err := http.NewRequest("POST", u.String(), &body)
	if err != nil {
		return nil, err
	}
	header := req.Header
	header.Set("Content-Type", "application/json")
	if c.JWTSigner != nil {
		c.JWTSigner.Sign(req)
	}
	return req, nil
}

// ViewUsersPath computes a request path to the view action of users.
func ViewUsersPath() string {

	return fmt.Sprintf("/users/me")
}

// Get user by authorization token
func (c *Client) ViewUsers(ctx context.Context, path string) (*http.Response, error) {
	req, err := c.NewViewUsersRequest(ctx, path)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewViewUsersRequest create the request corresponding to the view action endpoint of the users resource.
func (c *Client) NewViewUsersRequest(ctx context.Context, path string) (*http.Request, error) {
	scheme := c.Scheme
	if scheme == "" {
		scheme = "http"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	if c.JWTSigner != nil {
		c.JWTSigner.Sign(req)
	}
	return req, nil
}
